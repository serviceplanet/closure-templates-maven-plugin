package nl.serviceplanet.maven.closureteemplatecompiler;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

/**
 * Provides a Maven goal to invoke the Closure Template (Soy) template to JVM byte code compiler.
 * 
 * @author Jasper Siepkes <siepkes@serviceplanet.nl>
 */
@Mojo(name = "soy-to-bytecode", defaultPhase = LifecyclePhase.VERIFY)
public final class ClosureTemplateSoyToJbcMojo extends AbstractMojo {

	/** Flag to specify which Soy source files to compile. */
	private static final String SRCS_FLAG = "--srcs";
	/** Flag to specify the full path to the output JAR with bytecode. */
	private static final String OUTPUT_FLAG = "--output";
	
	@Parameter(defaultValue = "${project}", required = true, readonly = true)
	private MavenProject project;
	
	@Parameter(property = "soySources")
	private String soySources;

	private Path compiledTemplatesJar = null;
	
	@Override
	public void execute() throws MojoExecutionException, MojoFailureException {		 
		try {
			try {
				compiledTemplatesJar = Files.createTempFile("soy-bytecode", ".jar");
				getLog().debug(String.format("Using temporary file '%s' for soy compiler output.", 
						compiledTemplatesJar.toString()));
			} catch (Exception e) {
				throw new MojoExecutionException("Unable to create temporary file for compiled templates.", e);
			}

			// Generate the "command line" arguments we are going to pass to the Soy compiler.
			String[] compilerCliArgs = new String[] {
					SRCS_FLAG,
					soySources
			};
			
			try {
				getLog().debug("Invoking Soy compiler.");
				EmbeddedSoyCompiler compiler = new EmbeddedSoyCompiler(compiledTemplatesJar);
				int exitCode = compiler.run(compilerCliArgs, System.err);
				if (exitCode != 0) {
					throw new MojoExecutionException(String.format("Soy compiler exited with non-zero exit code (%s).", exitCode));
				}
			} catch (MojoExecutionException e) {
				throw e;
			} catch (Exception e) {
				throw new MojoExecutionException("The 'SoyToJbcSrcCompiler' was unable to complete successfully.", e);
			}

			try {
				// Extract the generated JAR file to the classes directory in the Maven target folder.
				extractJar(compiledTemplatesJar, Path.of(project.getBuild().getOutputDirectory()));
			} catch (Exception e) {
				throw new MojoExecutionException("Unable to extract JAR file generated by 'SoyToJbcSrcCompiler' to 'classes' folder.", e);
			}
		} finally {
			if (compiledTemplatesJar != null) {
				try {
					Files.deleteIfExists(compiledTemplatesJar);
				} catch (IOException e) {
					getLog().debug(String.format("Unable to delete temporary JAR output file '%s'.", compiledTemplatesJar), e);
				}
			}
		}
	}
	
	private void extractJar(Path jarFile, Path extractTarget) throws IOException {
		byte[] buffer = new byte[1024];
		try (InputStream inputStream = Files.newInputStream(jarFile);
			 ZipInputStream zipInputStream = new ZipInputStream(inputStream)) {
			ZipEntry zipEntry = zipInputStream.getNextEntry();
			
			while (zipEntry != null) {
				Path newPath = Path.of(extractTarget.normalize().toString(), zipEntry.getName());
				if (zipEntry.getName().contains("META-INF")) {
					getLog().debug(String.format("%s - Not extracting.", newPath));
					// We only want classes and resources in the target class directory.
					zipEntry = zipInputStream.getNextEntry();
					continue;
				}
				getLog().debug(String.format("%s - Extracting", newPath));
				
				if (zipEntry.isDirectory()) {
					if (Files.exists(newPath) && !Files.isDirectory(newPath)) {
						throw new IOException(String.format("Path '%s' exists but is not a directory and should be a directory according to the ZIP file.", 
								newPath));
					} else {
						if (!Files.exists(newPath)) {
							Files.createDirectories(newPath);
						}
					}
				} else {
					// Directories don't always come before files which are in these directories in ZIP files.
					Path newPathParent = newPath.getParent();
					if (Files.exists(newPathParent) && !Files.isDirectory(newPathParent)) {
						throw new IOException(String.format("Path '%s' exists but is not a directory and should be a directory according to the ZIP file.",
								newPath));
					} else {
						Files.createDirectories(newPathParent);
					}
					
					try (OutputStream outputStream = Files.newOutputStream(newPath)) {
						int len;
						while ((len = zipInputStream.read(buffer)) > 0) {
							outputStream.write(buffer, 0, len);
						}					
					}
				}
				
				zipEntry = zipInputStream.getNextEntry();
			}

			zipInputStream.closeEntry();
		}
	}
}
